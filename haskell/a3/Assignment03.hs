module Assignment03 where

-- Imports everything from the FiniteState module
import FiniteState

-- Another type we'll use as symbols for some FSAs
data SegmentPKIU = P | K | I | U | WB deriving (Show,Eq)

-- A list-like type that will be useful for computing forward values
data SnocList a = ESL | (SnocList a) ::: a deriving Show

-- The word ``hello'' encoded as a snoc list of characters
sl :: SnocList Char
sl = ((((ESL ::: 'h') ::: 'e') ::: 'l') ::: 'l') ::: 'o'

-- Checks that all states and symbols mentioned in the transition 
-- table (i.e. delta) come from the provided lists of states and symbols.
fsaSanityCheck :: (Eq a) => Automaton a -> Bool
fsaSanityCheck m =
    let (states, syms, i, f, delta) = m in
    let validTransition (q1,x,q2) = elem q1 states && elem x syms && elem q2 states in
    and (map validTransition delta)

------------------------------------------------------------------
------------------------------------------------------------------
-- IMPORTANT: Please do not change anything above here.
--            Write all your code below this line.


-- PART ONE

--generates strings containing an amount of 'V's that is a non-zero multiple of three
fsa_countVs :: Automaton SegmentCV
fsa_countVs = ([54,73,21,38], [C,V], [54], [38], [  (54,C,54),
                                                    (54,V,73),
                                                    (73,C,73),
                                                    (73,V,21),
                                                    (21,C,21),
                                                    (21,V,54),
                                                    (21,V,38),
                                                    (38,C,38) ] )

-- PART TWO

addToFront :: a -> SnocList a -> SnocList a
--pretty much exactly like adding an item to a normal list - just swap the order of some terms.
addToFront i sl = case sl of
                        ESL -> ESL ::: i
                        rest:::x -> (addToFront i rest) ::: x


toSnoc :: [a] -> SnocList a
--addToFront is very useful in writing this function
toSnoc l = case l of
                [] -> ESL
                x : rest -> addToFront x (toSnoc rest)


-- PART THREE

forward :: (Eq a) => Automaton a -> SnocList a -> State -> Bool

-- surprisingly similar to 'backward.' Uses snoclists instead of conslists to check in the reverse order.
forward m sl q = let (states, sym, i, f, delta) = m in
                        case sl of
                            ESL -> elem q i
                            (rest ::: x) -> or (map (\q1 -> (forward m rest q1 && elem(q1,x,q) delta)) states)



generates2 :: (Eq a) => Automaton a -> [a] -> Bool

--works similarly to 'generates,' but uses my new forward function combined with toSnoc. neat!
generates2 m w =
        let (states, syms, i, f, delta) = m in
            or (map (\q1 -> (forward m (toSnoc w) q1 && elem q1 f)) states)


-- PART FOUR

--E

--this FSA only generates strings containing two or more Cs
fsa_twoCs :: Automaton SegmentCV
fsa_twoCs = ([1,2,3], [C,V], [1], [3], [ (1,V,1),
                                         (1,C,1),
                                         (1,C,2),
                                         (2,V,2),
                                         (2,C,3),
                                         (3,C,3),
                                         (3,V,3)
                                        ] )


--F

-- this automaton was very difficult to design. I wasn't able to come up with a solution that works.
--so, I used a cheap tactic. I defined two automatons that check for each individual requirement, and made sure the given string worked with both of them


--this FSA only generates strings containing an even number of Vs
fsa_evenV :: Automaton SegmentCV
fsa_evenV = ( [1,2], [C,V], [1], [1], [ (1,C,1),
                                        (1,V,2),
                                        (2,C,2),
                                        (2,V,1)
                                      ])
--this FSA only generates strings containing an odd number of Cs
fsa_oddC :: Automaton SegmentCV
fsa_oddC = ( [1,2], [C,V], [1], [2], [ (1,V,1),
                                        (1,C,2),
                                        (2,V,2),
                                        (2,C,1),
                                        ])


--oddEven isn't actually an FSA - it's just a fancy way of using generates to check that a string is generated by both smaller automata
fsa_oddEven :: [SegmentCV] -> Bool
fsa_oddEven l = ((generates fsa_evenV l) && (generates fsa_oddC l))

{-
usage: fsa_oddEven [C,V,V] == True, equivalent to generates fsa_oddEven [C,V,V] on the handout
you could say that I wasn't able to meet the requirement, but I like to think that my solution is even better because I inlined the 'generates' function. how convenient!

pls :)
-}



--G

--generates strings where the third letter is a C
fsa_thirdC :: Automaton SegmentCV
fsa_thirdC = ( [1,2,3,4], [C,V], [1], [4], [ (1,C,2),
                                             (1,V,2),
                                             (2,C,3),
                                             (2,V,3),
                                             (3,C,4),
                                             (4,C,4),
                                             (4,V,4)                                            
                                            ] )

--H

--generates strings where the third-to-last letter is a C
--simply the automaton in G, but with the transition order swapped
fsa_thirdlastC :: Automaton SegmentCV
fsa_thirdlastC = ( [1,2,3,4], [C,V], [1], [4], [ (1,C,1),
                                                 (1,V,1),
                                                 (1,C,2),
                                                 (2,C,3),
                                                 (2,V,3),
                                                 (3,C,4),
                                                 (3,V,4)
                                            ] )

--I

--all vowels within generated words must be identical to each other
fsa_harmony :: Automaton SegmentPKIU
fsa_harmony = ( [1,2,3], [P,I,K,U,WB], [1], [1,2,3], [ (1,P,1),
                                                       (1,K,1),
                                                       (1,WB,1),
                                                       (1,I,2),
                                                       (2,I,2),
                                                       (2,P,2),
                                                       (2,K,2),
                                                       (2,WB,1),
                                                       (1,U,3),
                                                       (3,U,3),
                                                       (3,P,3),
                                                       (3,K,3),
                                                       (3,WB,3)
                                                    ] )

--J

-- U can only occur after some occurence of P. Not adjacent
fsa_PU :: Automaton SegmentPKIU
fsa_PU = ( [1,2], [P,I,K,U], [1], [1], [ (1,I,1),
                                         (1,K,1),
                                         (1,P,1),
                                         (1,P,2),
                                         (2,K,2),
                                         (2,I,2),
                                         (2,U,1)
                                      ] )

--K

-- U can only occur after an adjacent occurence of P
fsa_adjacentPU :: Automaton SegmentPKIU
fsa_adjacentPU = ( [1,2], [P,I,K,U], [1], [1], [ (1,I,1),
                                             (1,K,1),
                                             (1,P,1),
                                             (1,P,2),
                                             (2,U,1)
                                      ] )